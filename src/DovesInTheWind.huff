#include "huffmate/utils/Errors.huff"
#include "huffmate/utils/JumpTableUtil.huff"
#include "huffmate/utils/LibBit.huff"
#include "huffmate/math/FixedPointMath.huff"
#include "huffmate/math/Trigonometry.huff"

////////////////////////////////////////////////////////////////
//                         INTERFACES                         //
////////////////////////////////////////////////////////////////

#define function owner() view returns (address)

#define event NewLeader(address indexed solver, uint256 score)

////////////////////////////////////////////////////////////////
//                         CONSTANTS                          //
////////////////////////////////////////////////////////////////

#define constant HIGH_SCORE_SLOT = FREE_STORAGE_POINTER()
#define constant TWO_BYTE_MASK = 0xFFFF
#define constant RP_FOUR_BYTE_MASK = 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000
#define constant RP_EIGHT_BYTE_MASK = 0xFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000
#define constant ADDRESS_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

////////////////////////////////////////////////////////////////
//                           TABLES                           //
////////////////////////////////////////////////////////////////

#define jumptable__packed DISPATCH = {
    dispatch_0 dispatch_1 dispatch_2 dispatch_3 dispatch_4
}

////////////////////////////////////////////////////////////////
//                         CHALLENGE                          //
////////////////////////////////////////////////////////////////

#define macro CONSTRUCTOR() = {
    // Set the high score to max int
    0x00 not [HIGH_SCORE_SLOT] sstore
}

#define macro MAIN() = {
    0x04 calldataload          // [cd]

    // Will revert if an invalid dispatch table index is passed as the
    // selector.
    __tablestart(DISPATCH)     // [tablestart, cd]
    0x00 calldataload 0xE0 shr // [sig, tablestart, cd]

    // TODO: Enforce table size limit so that people can't use a 2 byte
    //       value after the table as their dispatch jumpdest.
    //       If the jumpdest of `WILDCARD` doesn't show up in the bytecode
    //       after the table, it should be safe, but there could still
    //       *potentially* be an unintended exploit if we don't introduce
    //       this check.
    // 0x05 dup2 lt ASSERT()      // [sig, tablestart, cd]

    RETRIEVE_FROM_PACKED_JT()  // [jumpdest, cd]
    jump                       // [cd]


    // DISPATCH LOGIC
    // ==============
    dispatch_0:
        HONEYPOT_0()
    dispatch_1:
        HONEYPOT_1()
    dispatch_2:
        HONEYPOT_2()
    dispatch_3:
        WILDCARD()
    dispatch_4:
        HONEYPOT_4()

    // This dest can only be jumped to by `WILDCARD`
    // The challenge before the challenge >:D
    magic_dest:
        [ADDRESS_MASK] and     // [solution_addr]

        SOLVE()
        stop

    fail:
        PANIC()
}

/// @dev Offers a jump to an arbitrary destination in exchange for a brute
/// forced hash. The first part of the challenge is to find the inputs for a
/// hash that satisfies the constraints and causes this macro to jump to
/// the `SOLVE` entrypoint.
///
/// Includes the function selector, tx.origin address, and cd[4:12]
/// in the hash input.
///
/// 32 bits in total need to be brute forced:
/// - the final 2 bytes of the hash must equal D073
/// - the first 2 bytes of the hash must equal the desired jumpdest
#define macro WILDCARD() = {
    0x00 calldataload          // [cd]
    [RP_FOUR_BYTE_MASK] and    // [sig]
    0x00 mstore                // []
    origin 0x60 shl            // [origin << 0x60]
    0x04 mstore                // []
    0x04 calldataload          // [cd]
    [RP_EIGHT_BYTE_MASK] and   // [cd & 0xFFFFFFFFFFFFFFFF...]
    0x18 mstore                // []
    0x20 0x00 sha3             // [hash]
    dup1                       // [hash, hash]
    [TWO_BYTE_MASK] and        // [hash & 0xFFFF, hash]
    0xD073 eq                  // [0xD073 == (hash & 0xFFFF), hash]
    ASSERT()                   // [hash]
    0xF0 shr jump              // []
}

/// @dev Solve entrypoint 
#define macro SOLVE() = takes (1) returns (1) {
    // Input stack:               [solution_addr]

    // "Solution must be a contract"
    __RIGHTPAD(0x536f6c7574696f6e206d757374206265206120636f6e7472616374)
    0x1B                       // [0x1b, "Solution must be a contract", solution_addr]
    dup3 extcodesize           // [codesize(solution), 0x1b, "Solution must be a contract", solution_addr]
    iszero iszero              // [codesize(solution) != 0, 0x1b, "Solution must be a contract", solution_addr]
    REQUIRE()                  // [solution_addr]

    // "Solution is not yours"
    __RIGHTPAD(0x536f6c7574696f6e206973206e6f7420796f757273)
    0x15                       // [0x15, "Solution is not yours", solution_addr]
    dup3                       // [solution_addr, 0x15, "Solution is not yours", solution_addr]
    GET_OWNER() origin eq      // [solution_owner == tx.origin, 0x15, "Solution is not yours", solution_addr]
    REQUIRE()                  // [solution_addr]

    // Store function selector in memory @ 0x00
    // TODO: Use a selector that is not on 4byte / eth sig DB
    // "solve(uint)" for now
    __FUNC_SIG("solve(uint256)") 0x00 mstore

    // TODO: Generate address-specific problem input & store in mem @ 0x20
    GEN_CHALLENGE()            // [challenge_input, solution_addr]
    0x20 mstore                // [solution_addr]
    
    dup1 extcodesize           // [codesize(solution), solution_addr]
    swap1                      // [solution_addr, codesize(solution)]
    gas                        // [gasBefore, solution_addr, codesize(solution)]
    swap1                      // [solution_addr, gasBefore, codesize(solution)]

    // Perform call to solution contract with the generated input
    0x00 0x24 0x1c 0x00        // [0x00, 0x1c, 0x24, 0x00, solution_addr, gasBefore, codesize(solution)]
    0x20 swap5                 // [solution_addr, 0x00, 0x1c, 0x24, 0x00, 0x20, gasBefore, codesize(solution)]
    gas call                   // [success, gasBefore, codesize(solution)]

    // Ensure call to solution contract succeeded
    ASSERT()                   // [gasBefore, codesize(solution)]

    // TODO: Subtract PUSH / SWAP / ASSERT gas for an accurate result.
    gas swap1 sub              // [gasUsed, codesize(solution)]
    add                        // [newScore]

    // Assert that solution is valid
    0x20 0x00 dup1             // [0x00, 0x00, 0x20, newScore]
    returndatacopy             // [newScore]
    0x00 mload                 // [solution, newScore]
    // VALIDATE_SOLUTION()        // [newScore]
    pop
    
    // Assert that the new score is less than the old score
    [HIGH_SCORE_SLOT] sload    // [prevScore, newScore]
    // TODO: Verbose revert message on failure
    dup2 lt iszero             // [newScore >= prevScore, newScore]
    fail jumpi                 // [newScore]

    // Mint Reward to msg.sender
    // TODO: Add logic in NFT to hold off on claiming until the end of the game.
    //       First solver gets their special edition NFT (id = 0) immediately.
    caller                     // [sender, newScore]
    SAFE_MINT_NFT()            // [newScore]

    // Update highest score
    dup1 [HIGH_SCORE_SLOT]     // [HIGH_SCORE_SLOT, newScore, newScore]
    sstore                     // [newScore]

    // Emit event
    caller 0x00 mstore         // [newScore]
    0x20 mstore                // []
    0x40 0x00 log0             // []

    stop

    // Return stack:              []
}

////////////////////////////////////////////////////////////////
//                       SCORE KEEPING                        //
////////////////////////////////////////////////////////////////

/// @dev Used to mint a new Reward NFT
#define macro SAFE_MINT_NFT() = takes (1) {
    // Input stack:               [to]

    0x6a627842 0xE0 shl        // [0xE06a627842, to]
    0x00 mstore                // [to]
    0x04 mstore                // []

    0x00 dup1 0x24 dup2 dup1   // [0x00, 0x00, 0x20, 0x00, 0x00]
    [NFT_ADDR]                 // [NFT_ADDR, 0x00, 0x00, 0x24, 0x00, 0x00]
    gas call                   // [success]

    // Revert if mint failed.
    ASSERT()                   // []
}

////////////////////////////////////////////////////////////////
//                          HELPERS                           //
////////////////////////////////////////////////////////////////

/// @dev Staticcalls a contract's "owner()" function and leaves
///      the result on the stack. Does not check if the address
///      being called is a contract.
#define macro GET_OWNER() = takes (1) returns (1) {
    // Input stack:               [solution_addr]

    __FUNC_SIG(owner) 0x00 mstore

    0x00 0x04 0x1c 0x20 swap4  // [solution_addr, 0x1c, 0x04, 0x00, 0x20]
    gas staticcall             // [success]

    // Revert if call failed.
    ASSERT()                   // []

    // Store result on the stack
    0x00 mload                 // [owner]

    // Return stack:              [owner]
}

/// @dev Generates a challenge specific to the solution_addr
#define macro GEN_CHALLENGE() = takes (1) returns (1) {
    0x01 // TODO
}

/// @dev Checks if a solution to the optimization challenge is valid
#define macro VALIDATE_SOLUTION() = takes (1) returns (1) {
    // TODO
}

////////////////////////////////////////////////////////////////
//                         HONEYPOTS                          //
////////////////////////////////////////////////////////////////

/// @dev Basically a noop, random mulDivDown call with calldata as the denominator.
#define macro HONEYPOT_0() = {
    // Input stack:               [cd]

    0xa57b3d3e                 // [0xa57b3d3e, cd]
    0x957f47157a               // [0x957f47157a, 0xa57b3d3e, cd]
    MUL_DIV_DOWN(fail)         // [0x957f47157a * 0xa57b3d3e / cd]

    0x00 mstore                // []
    0x20 0x00 return
}

/// @dev Creates an infinite loop on itself, will run out of gas.
#define macro HONEYPOT_1() = {
    // Input stack:               [cd]

    0x01 0x08 shl              // [0x0100, cd]
    returndatasize add         // [0x0100 + returndatasize, cd]
    chainid and                // [(0x1000 + returndatasize) & chainid, cd]

    dispatch_1 jump            // [(0x1000 + returndatasize) & chainid, cd]

    // Unnecessary
    stop
}

/// @dev Another noop 
#define macro HONEYPOT_2() = {
    // Input stack:               [cd]

    SIN()                      // [sin(cd)]
    stop
    SQRT()
}

/// @dev Retrieves the number of set bits in calldata[4:36]
#define macro HONEYPOT_4() = {
    // Input stack:               [cd]
    POP_COUNT()

    0x00 mstore                // []
    0x20 0x00 return
}
